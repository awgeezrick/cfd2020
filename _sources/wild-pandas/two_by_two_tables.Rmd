---
jupyter:
  jupytext:
    split_at_heading: true
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.1'
      jupytext_version: 1.2.4
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

# The magic of 2 by 2 tables

```{python}
# Our usual imports
import numpy as np
import pandas as pd
# Safe settings for Pandas.
pd.set_option('mode.chained_assignment', 'raise')
```

At the end of the [noble politics](noble_politics) page, you came across an
enigma, from analyzing two by two tables of counts.

This page shows you another version of that enigma, and gives a few
explanations for these strange effects.

To start with, we make a simple data frame, where each row corresponds
to a person.  Each person, and therefore, each row, has two labels.  If you
have read the Noble Politics page, you will see what inspired this example.

The first label for each person, called "Party" can be either "Yes", or "No".

The second label for each person, called "Respondent", can be either "R" or
"B".

Here we use Pandas to create our data frame from scratch:

```{python}
# Create a data frame from scratch with some data.
people = pd.DataFrame([["Yes", "R"],
                       ["Yes", "R"],
                       ["Yes","R"],
                       ["No", "R"],
                       ["No", "R"],
                       ["Yes","B"],
                       ["Yes","B"],
                       ["No","B"]],
                       columns = ['Respondent', 'Party'])
# Show the result
people
```

We can ask Pandas to make a 2 by 2 table of counts, for these labels.  Each entry in the table gives the number of times the combination of labels occurs.  For example, the "Yes" row, "R" column gives the number of rows that have a "Yes" label for "Party" *and* a "R" label for "Respondent":

```{python}
two_by_two = pd.crosstab(people['Party'], people['Respondent'])
two_by_two
```

You might want to confirm these counts.  You should see that there are in fact
3 rows which have both the "Yes" label and the "R" label, and this matches the
bottom right entry in the `pd.crosstab` table.

Now let's say we want to create a random association between the "Party" (Yes/No) column and the "Respondent" (R/B) column.   We can do that by shuffling (permuting) the Yes/No values, and recreating the table, like this:

```{python}
parties = people['Party']
respondents = people['Respondent']
permuted_tab_1 = pd.crosstab(np.random.permutation(parties), respondents)
permuted_tab_1
```

Let's make another couple of those random tables:

```{python}
permuted_tab_2 = pd.crosstab(np.random.permutation(parties), respondents)
permuted_tab_2
```

```{python}
permuted_tab_3 = pd.crosstab(np.random.permutation(parties), respondents)
permuted_tab_3
```

You will see that, if the top left value goes up, or down, compared to the
original table, then the bottom right value goes up, or down, by the same
amount.  Call the change in the top-right value, from the original `c`.  The
original value for that element was 1, so if the new value is 2, $c = 1$.  If
the new value was 0, then $c = -1$.

You will also see that the bottom left value goes *down* by the same amount as
the top left value goes up.  If the top left value goes up by $c$, then the
bottom left value does down by $c$.

All the values in the table appear to be linked, and move in lock-step.

This is another version of the enigma you saw at the end of the [Noble
Politics](noble_politics) page.

## Why are the table values linked?

### Explanation 1: the row and column totals cannot change

The first explanation for the relationship between the values is --- the total
counts over the rows and columns are fixed.

The sums of the counts along the columns are fixed, regardless of the ordering
of the "Yes" and "No" labels. If we add the "Yes" and "No" counts for "R", we
have the total number of rows with "R" in the table (5) because each row can
only have a "Yes" or a "No", so every "R" value has either a "Yes" or a "No".

For the same reason, the "Yes" and "No" counts for "B" add up to the number of rows with a "B" label (3).

These values, 5 and 3, must be the same regardless of the ordering of the
"Yes" and "No" labels, and therefore, the relationship of "Yes" or "No" to "R"
and "B".

Similarly for the sum of the counts along the rows.  If we add the "R" and "B"
counts for the "Yes" rows we get the total number of "Yes" rows (5).  There
are 3 "No" rows.  That will be so regardless of ordering of the "Yes" and "No"
labels.

This means that if the top-left value goes up by 1 (the "No", "R") value, then
the bottom-left value ("Yes", "R") must go down by 1, because the total number
of "R" rows cannot change.  It also means that the top-right value ("No", "B")
has to go down by 1, because the total number of "No" rows can't change.  And
for the same reason, the "Yes", "B" value has to go *up* by 1, like the
top-left value, because the total number of "Yes", and the total number of "B"
values cannot change.

You may now see that, if you give me the value for any one of the four
elements in the table, I can fill in the rest, because they follow from the
fact that I know what the rows and columns have to add up to.

### Explanation 2: what goes up, must come down

Here we think about what happens as we permute the Yes/No labels.  The same
argument applies to permuting the R/B labels, and in fact, to permuting both
the labels.

Consider the original table.

```{python}
two_by_two
```

Now consider permutations in the order of the Yes/No column.  We will just
permute the first "Yes", for now.

Imagine the first "Yes" gets swapped with the "Yes" in one of the other "R",
"Yes" rows.  We still end up with the same two by two counts table.

Next swap the first "Yes" with the "No" in one of the "R", "No" rows.  The
first row is "R", "No" but the other row has now become "R", "Yes", we still
have the same number of "R", "Yes" and "R", "No", and the counts table doesn't
change.

Now swap the first "Yes" with the "Yes" in one of the "B", "Yes" rows.  We
still have the same number of "R", "Yes" and "B", "Yes" rows, just in a
different row order, and the counts table doesn't change.

Last, we swap the first "Yes" with the "No" in one of the "B", "No" rows. Now,
for the first time, the counts table does change, like this:

```{python}
# The data frame with first "Yes" permuted to last row.
perm_people = pd.DataFrame([["No", "R"],
                            ["Yes", "R"],
                            ["Yes","R"],
                            ["No", "R"],
                            ["No", "R"],
                            ["Yes","B"],
                            ["Yes","B"],
                            ["Yes","B"]],
                            columns = ['Respondent', 'Party'])
# Show cross-tabulation
pd.crosstab(perm_people['Party'], perm_people['Respondent'])
```

When we do this single change, we have:

* One less "R", "Yes" row (bottom-right count goes down by 1)
* One less "B", "No" row (top-left count down by 1)
* One more "R", "No" row (bottom-left count up by 1)
* One more "B", "Yes" row (top-right count up by 1)

As we permute the "Yes", "No" labels, we either leave the total number of
unique "R/B", "Yes/No" pairings unchanged, or we change the number of all the
pairings at once.
